<html>
<head>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/underscore@1.13.1/underscore-min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/flatgeobuf@3.21.3/dist/flatgeobuf-geojson.min.js"></script>
</head>
<body>
  <div>
    <h1 id="header">Inspect FGB File</h1>
    <h3 id="url"></h3>
    <div style="height: 50vh;" id="map"></div>
  </div>
    <script>
     class UI {
       constructor(url) {
         this.url = url;
         this.updateResults = _.throttle(this._updateResults.bind(this), 1000);
       }

       async init() {
         this.map = L.map('map').setView([39, -104], 6);
         L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
           maxZoom: 19,
           attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
         }).addTo(this.map);

         let r = this.updateResults();
         await r;

         this.rectangle = L.rectangle(this.latLngBounds(), { color: "yellow", fillOpacity: 0.7, opacity: 1.0 })
                           .addTo(this.map);
         this.map.on("moveend", () => {
           this.rectangle.setBounds(this.latLngBounds());
           this.updateResults();
         });
       }

       handleHeaderMeta(headerMeta) {
         /* const header = document.getElementById('header')
          * const formatter = new JSONFormatter(headerMeta, 10)
          * header.appendChild(JSON.stringify(headerMeta)); */
       }

       async _updateResults() {
         console.log('update results...');
         // remove the old results
         if (this.previousResults) {
           this.previousResults.remove();
         }
         const nextResults = L.layerGroup().addTo(this.map);
         this.previousResults = nextResults;

         // Use flatgeobuf JavaScript API to iterate features as geojson.
         // Because we specify a bounding box, flatgeobuf will only fetch the relevant subset of data,
         // rather than the entire file.
         let iter = flatgeobuf.deserialize(this.url, this.bbox(), this.handleHeaderMeta.bind(this));
         for await (let feature of iter) {
           console.log('handle feature...', feature);
           const defaultStyle = {
             color: 'blue',
             weight: 2,
             fillOpacity: 0.1,
           };

           L.geoJSON(feature, {
             style: defaultStyle,
           }).addTo(nextResults);
         }
       }

       // For the example, we fix a visible Rect representing the query
       // bounding box in the middle of the map
       boundsForRect() {
         const widthMeters = 500000;
         console.log('boundsForRect', this.map.getCenter());
         console.log('boundsForRect -width', this.map.getCenter().toBounds(widthMeters));
         return this.map.getCenter().toBounds(widthMeters);
       }

       bbox() {
         const bounds = this.boundsForRect();
         return {
           minX: bounds._southWest.lng,
           minY: bounds._southWest.lat,
           maxX: bounds._northEast.lng,
           maxY: bounds._northEast.lat,
         };
       }

       latLngBounds() {
         const bb = this.bbox();
         return L.latLngBounds(
           L.latLng(bb.minY, bb.minX),
           L.latLng(bb.maxY, bb.maxX)
         );
       }
     }

     document.addEventListener("DOMContentLoaded", () => {
       const url = new URLSearchParams(window.location.search).get("url");

       if (url == null) {
         alert("Missing 'url' query param pointing to a .fgb file.");
       } else {
         document.getElementById('url').textContent = url;
         const ui = new UI(url)
         ui.init();
       }
     });
    </script>
</body>
</html>
